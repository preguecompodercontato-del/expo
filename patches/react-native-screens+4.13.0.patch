diff --git a/node_modules/react-native-screens/android/src/main/java/com/swmansion/rnscreens/Screen.kt b/node_modules/react-native-screens/android/src/main/java/com/swmansion/rnscreens/Screen.kt
index f9ff057..948337f 100644
--- a/node_modules/react-native-screens/android/src/main/java/com/swmansion/rnscreens/Screen.kt
+++ b/node_modules/react-native-screens/android/src/main/java/com/swmansion/rnscreens/Screen.kt
@@ -33,13 +33,15 @@ import com.swmansion.rnscreens.events.HeaderHeightChangeEvent
 import com.swmansion.rnscreens.events.SheetDetentChangedEvent
 import com.swmansion.rnscreens.ext.asScreenStackFragment
 import com.swmansion.rnscreens.ext.parentAsViewGroup
+import com.swmansion.rnscreens.gamma.common.FragmentProviding
 
 @SuppressLint("ViewConstructor") // Only we construct this view, it is never inflated.
 class Screen(
     val reactContext: ThemedReactContext,
 ) : FabricEnabledViewGroup(reactContext),
-    ScreenContentWrapper.OnLayoutCallback {
-    val fragment: Fragment?
+    ScreenContentWrapper.OnLayoutCallback,
+    FragmentProviding {
+    override val fragment: Fragment?
         get() = fragmentWrapper?.fragment
 
     val sheetBehavior: BottomSheetBehavior<Screen>?
diff --git a/node_modules/react-native-screens/android/src/main/java/com/swmansion/rnscreens/ScreenContainer.kt b/node_modules/react-native-screens/android/src/main/java/com/swmansion/rnscreens/ScreenContainer.kt
index 400f209..6c651f9 100644
--- a/node_modules/react-native-screens/android/src/main/java/com/swmansion/rnscreens/ScreenContainer.kt
+++ b/node_modules/react-native-screens/android/src/main/java/com/swmansion/rnscreens/ScreenContainer.kt
@@ -176,26 +176,27 @@ open class ScreenContainer(
     private fun setupFragmentManager() {
         var parent: ViewParent = this
         // We traverse view hierarchy up until we find screen parent or a root view
-        while (!(parent is ReactRootView || parent is Screen || parent is FragmentProviding) &&
+        while (!(parent is ReactRootView || parent is FragmentProviding) &&
             parent.parent != null
         ) {
             parent = parent.parent
         }
-        // If parent is of type Screen it means we are inside a nested fragment structure.
+        // If parent is of type FragmentProviding it means we are inside a nested fragment structure.
         // Otherwise we expect to connect directly with root view and get root fragment manager
-        if (parent is Screen) {
-            checkNotNull(
-                parent.fragmentWrapper?.let { fragmentWrapper ->
-                    parentScreenWrapper = fragmentWrapper
-                    fragmentWrapper.addChildScreenContainer(this)
-                    setFragmentManager(fragmentWrapper.fragment.childFragmentManager)
-                },
-            ) { "Parent Screen does not have its Fragment attached" }
-        } else if (parent is FragmentProviding) {
-            // TODO: We're missing parent-child relationship here between old container & new one
+        if (parent is FragmentProviding) {
+            if (parent is Screen) {
+                checkNotNull(
+                    parent.fragmentWrapper?.let { fragmentWrapper ->
+                        parentScreenWrapper = fragmentWrapper
+                        fragmentWrapper.addChildScreenContainer(this)
+                    },
+                ) { "Parent Screen does not have its Fragment attached" }
+            }  else {
+              // TODO: We're missing parent-child relationship here between old container & new one
+            }
             val fragmentManager =
                 checkNotNull(
-                    parent.getFragment(),
+                    parent.fragment,
                 ) { "[RNScreens] Parent $parent returned nullish fragment" }.childFragmentManager
             setFragmentManager(fragmentManager)
         } else {
diff --git a/node_modules/react-native-screens/android/src/main/java/com/swmansion/rnscreens/gamma/common/FragmentProviding.kt b/node_modules/react-native-screens/android/src/main/java/com/swmansion/rnscreens/gamma/common/FragmentProviding.kt
index 5c211a9..28998b6 100644
--- a/node_modules/react-native-screens/android/src/main/java/com/swmansion/rnscreens/gamma/common/FragmentProviding.kt
+++ b/node_modules/react-native-screens/android/src/main/java/com/swmansion/rnscreens/gamma/common/FragmentProviding.kt
@@ -7,5 +7,5 @@ import androidx.fragment.app.Fragment
  * can be used to retrieve child fragment manager for nesting operations.
  */
 interface FragmentProviding {
-    fun getFragment(): Fragment?
+    val fragment: Fragment?
 }
diff --git a/node_modules/react-native-screens/android/src/main/java/com/swmansion/rnscreens/gamma/helpers/FragmentManagerHelper.kt b/node_modules/react-native-screens/android/src/main/java/com/swmansion/rnscreens/gamma/helpers/FragmentManagerHelper.kt
index c809c4c..eca5902 100644
--- a/node_modules/react-native-screens/android/src/main/java/com/swmansion/rnscreens/gamma/helpers/FragmentManagerHelper.kt
+++ b/node_modules/react-native-screens/android/src/main/java/com/swmansion/rnscreens/gamma/helpers/FragmentManagerHelper.kt
@@ -23,7 +23,7 @@ object FragmentManagerHelper {
         // If parent adheres to FragmentProviding interface it means we are inside a nested fragment structure.
         // Otherwise we expect to connect directly with root view and get root fragment manager
         if (parent is FragmentProviding) {
-            return checkNotNull(parent.getFragment()) {
+            return checkNotNull(parent.fragment) {
                 "[RNScreens] Parent fragment providing view $parent returned nullish fragment"
             }.childFragmentManager
         } else {
diff --git a/node_modules/react-native-screens/android/src/main/java/com/swmansion/rnscreens/gamma/tabs/TabScreen.kt b/node_modules/react-native-screens/android/src/main/java/com/swmansion/rnscreens/gamma/tabs/TabScreen.kt
index 0d236d8..b52d2fa 100644
--- a/node_modules/react-native-screens/android/src/main/java/com/swmansion/rnscreens/gamma/tabs/TabScreen.kt
+++ b/node_modules/react-native-screens/android/src/main/java/com/swmansion/rnscreens/gamma/tabs/TabScreen.kt
@@ -29,6 +29,9 @@ class TabScreen(
 
     internal lateinit var eventEmitter: TabScreenEventEmitter
 
+    override val fragment: Fragment?
+        get() = tabScreenDelegate.get()?.getFragmentForTabScreen(this)
+
     var tabKey: String? = null
         set(value) {
             field =
@@ -79,8 +82,6 @@ class TabScreen(
         tabScreenDelegate = WeakReference(delegate)
     }
 
-    override fun getFragment(): Fragment? = tabScreenDelegate.get()?.getFragmentForTabScreen(this)
-
     private fun onTabFocusChangedFromJS() {
         tabScreenDelegate.get()?.onTabFocusChangedFromJS(this, isFocusedTab)
     }
diff --git a/node_modules/react-native-screens/ios/RNSScreenStack.h b/node_modules/react-native-screens/ios/RNSScreenStack.h
index f3a2363..40c5dc0 100644
--- a/node_modules/react-native-screens/ios/RNSScreenStack.h
+++ b/node_modules/react-native-screens/ios/RNSScreenStack.h
@@ -10,6 +10,15 @@
 
 NS_ASSUME_NONNULL_BEGIN
 
+@protocol RNSDismissibleModalProtocol <NSObject>
+
+// If NO is returned, the modal will not be dismissed when new modal is presented.
+// Use it on your own responsibility, as it can lead to unexpected behavior.
+- (BOOL)isDismissible;
+
+@end
+
+
 @interface RNSNavigationController
     : UINavigationController <RNSViewControllerDelegate, RNSBottomTabsSpecialEffectsSupporting>
 
diff --git a/node_modules/react-native-screens/ios/RNSScreenStack.mm b/node_modules/react-native-screens/ios/RNSScreenStack.mm
index 56481ac..fa709dd 100644
--- a/node_modules/react-native-screens/ios/RNSScreenStack.mm
+++ b/node_modules/react-native-screens/ios/RNSScreenStack.mm
@@ -571,47 +571,55 @@ - (void)setModalViewControllers:(NSArray<UIViewController *> *)controllers
 
   UIViewController *firstModalToBeDismissed = changeRootController.presentedViewController;
 
-  if (firstModalToBeDismissed != nil) {
-    const BOOL firstModalToBeDismissedIsOwned = [firstModalToBeDismissed isKindOfClass:RNSScreen.class];
-    const BOOL firstModalToBeDismissedIsOwnedByThisStack =
-        firstModalToBeDismissedIsOwned && [_presentedModals containsObject:firstModalToBeDismissed];
-
-    if (firstModalToBeDismissedIsOwnedByThisStack || !firstModalToBeDismissedIsOwned) {
-      // We dismiss every VC that was presented by changeRootController VC or its descendant.
-      // After the series of dismissals is completed we run completion block in which
-      // we present modals on top of changeRootController (which may be the this stack VC)
-      //
-      // There also might the second case, where the firstModalToBeDismissed is foreign.
-      // See: https://github.com/software-mansion/react-native-screens/issues/2048
-      // For now, to mitigate the issue, we also decide to trigger its dismissal before
-      // starting the presentation chain down below in finish() callback.
-      if (!firstModalToBeDismissed.isBeingDismissed) {
-        // If the modal is owned we let it control whether the dismissal is animated or not. For foreign controllers
-        // we just assume animation.
-        const BOOL firstModalToBeDismissedPrefersAnimation = firstModalToBeDismissedIsOwned
-            ? static_cast<RNSScreen *>(firstModalToBeDismissed).screenView.stackAnimation != RNSScreenStackAnimationNone
-            : YES;
-        [changeRootController dismissViewControllerAnimated:firstModalToBeDismissedPrefersAnimation completion:finish];
-      } else {
-        // We need to wait for its dismissal and then run our presentation code.
-        // This happens, e.g. when we have foreign modal presented on top of owned one & we dismiss foreign one and
-        // immediately present another owned one. Dismissal of the foreign one will be triggered by foreign controller.
-        [[firstModalToBeDismissed transitionCoordinator]
-            animateAlongsideTransition:nil
-                            completion:^(id<UIViewControllerTransitionCoordinatorContext> _) {
-                              finish();
-                            }];
+  // This check is for external modals that are not owned by this stack. They can prevent the dismissal of the modal by
+  // extending RNSDismissibleModalProtocol and returning NO from isDismissible method.
+  if (![firstModalToBeDismissed conformsToProtocol:@protocol(RNSDismissibleModalProtocol)] ||
+      [(id<RNSDismissibleModalProtocol>)firstModalToBeDismissed isDismissible]) {
+    if (firstModalToBeDismissed != nil) {
+      const BOOL firstModalToBeDismissedIsOwned = [firstModalToBeDismissed isKindOfClass:RNSScreen.class];
+      const BOOL firstModalToBeDismissedIsOwnedByThisStack =
+          firstModalToBeDismissedIsOwned && [_presentedModals containsObject:firstModalToBeDismissed];
+
+      if (firstModalToBeDismissedIsOwnedByThisStack || !firstModalToBeDismissedIsOwned) {
+        // We dismiss every VC that was presented by changeRootController VC or its descendant.
+        // After the series of dismissals is completed we run completion block in which
+        // we present modals on top of changeRootController (which may be the this stack VC)
+        //
+        // There also might the second case, where the firstModalToBeDismissed is foreign.
+        // See: https://github.com/software-mansion/react-native-screens/issues/2048
+        // For now, to mitigate the issue, we also decide to trigger its dismissal before
+        // starting the presentation chain down below in finish() callback.
+        if (!firstModalToBeDismissed.isBeingDismissed) {
+          // If the modal is owned we let it control whether the dismissal is animated or not. For foreign controllers
+          // we just assume animation.
+          const BOOL firstModalToBeDismissedPrefersAnimation = firstModalToBeDismissedIsOwned
+              ? static_cast<RNSScreen *>(firstModalToBeDismissed).screenView.stackAnimation !=
+                  RNSScreenStackAnimationNone
+              : YES;
+          [changeRootController dismissViewControllerAnimated:firstModalToBeDismissedPrefersAnimation
+                                                   completion:finish];
+        } else {
+          // We need to wait for its dismissal and then run our presentation code.
+          // This happens, e.g. when we have foreign modal presented on top of owned one & we dismiss foreign one and
+          // immediately present another owned one. Dismissal of the foreign one will be triggered by foreign
+          // controller.
+          [[firstModalToBeDismissed transitionCoordinator]
+              animateAlongsideTransition:nil
+                              completion:^(id<UIViewControllerTransitionCoordinatorContext> _) {
+                                finish();
+                              }];
+        }
+        return;
       }
-      return;
     }
   }
 
-  // changeRootController does not have presentedViewController but it does not mean that no modals are in presentation;
-  // modals could be presented by another stack (nested / outer), third-party view controller or they could be using
-  // UIModalPresentationCurrentContext / UIModalPresentationOverCurrentContext presentation styles; in the last case
-  // for some reason system asks top-level (react root) vc to present instead of our stack, despite the fact that
-  // `definesPresentationContext` returns `YES` for UINavigationController.
-  // So we first need to find top-level controller manually:
+  // changeRootController does not have presentedViewController but it does not mean that no modals are in
+  // presentation; modals could be presented by another stack (nested / outer), third-party view controller or they
+  // could be using UIModalPresentationCurrentContext / UIModalPresentationOverCurrentContext presentation styles; in
+  // the last case for some reason system asks top-level (react root) vc to present instead of our stack, despite the
+  // fact that `definesPresentationContext` returns `YES` for UINavigationController. So we first need to find
+  // top-level controller manually:
   UIViewController *reactRootVc = [self findReactRootViewController];
   UIViewController *topMostVc = [RNSScreenStackView findTopMostPresentedViewControllerFromViewController:reactRootVc];
 
@@ -625,7 +633,6 @@ - (void)setModalViewControllers:(NSArray<UIViewController *> *)controllers
       return;
     }
   }
-
   // We didn't detect any controllers for dismissal, thus we start presenting new VCs
   finish();
 }
